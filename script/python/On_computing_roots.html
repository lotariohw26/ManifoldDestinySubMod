<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>on_computing_roots</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="On_computing_roots_files/libs/clipboard/clipboard.min.js"></script>
<script src="On_computing_roots_files/libs/quarto-html/quarto.js"></script>
<script src="On_computing_roots_files/libs/quarto-html/popper.min.js"></script>
<script src="On_computing_roots_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="On_computing_roots_files/libs/quarto-html/anchor.min.js"></script>
<link href="On_computing_roots_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="On_computing_roots_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="On_computing_roots_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="On_computing_roots_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="On_computing_roots_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#on-computing-roots-of-quartic-and-cubic-equations-in-python" id="toc-on-computing-roots-of-quartic-and-cubic-equations-in-python" class="nav-link active" data-scroll-target="#on-computing-roots-of-quartic-and-cubic-equations-in-python">On computing roots of quartic and cubic equations in Python</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#numerical-algorithms" id="toc-numerical-algorithms" class="nav-link" data-scroll-target="#numerical-algorithms">Numerical algorithms</a>
  <ul class="collapse">
  <li><a href="#function-numpy.roots" id="toc-function-numpy.roots" class="nav-link" data-scroll-target="#function-numpy.roots">Function <code>numpy.roots</code></a></li>
  <li><a href="#function-numpy.linalg.eigvals" id="toc-function-numpy.linalg.eigvals" class="nav-link" data-scroll-target="#function-numpy.linalg.eigvals">Function <code>numpy.linalg.eigvals</code></a></li>
  </ul></li>
  <li><a href="#what-about-analytical-solutions-to-cubic-and-quartic-equations" id="toc-what-about-analytical-solutions-to-cubic-and-quartic-equations" class="nav-link" data-scroll-target="#what-about-analytical-solutions-to-cubic-and-quartic-equations">What about analytical solutions to cubic and quartic equations?</a>
  <ul class="collapse">
  <li><a href="#implementation-for-a-single-polynomial" id="toc-implementation-for-a-single-polynomial" class="nav-link" data-scroll-target="#implementation-for-a-single-polynomial">Implementation for a single polynomial</a></li>
  <li><a href="#just-in-time-compiler-from-numba" id="toc-just-in-time-compiler-from-numba" class="nav-link" data-scroll-target="#just-in-time-compiler-from-numba">Just-in-time compiler from Numba</a></li>
  <li><a href="#vectorized-analytical-closed-form-solvers" id="toc-vectorized-analytical-closed-form-solvers" class="nav-link" data-scroll-target="#vectorized-analytical-closed-form-solvers">Vectorized analytical closed-form solvers</a></li>
  </ul></li>
  <li><a href="#summary-tldr" id="toc-summary-tldr" class="nav-link" data-scroll-target="#summary-tldr">Summary (TL;DR)</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">



<section id="on-computing-roots-of-quartic-and-cubic-equations-in-python" class="level1">
<h1>On computing roots of quartic and cubic equations in Python</h1>
<p><em>by Nino Krvavica (<a href="nino.krvavica@uniri.hr">nino.krvavica@uniri.hr</a>)</em></p>
<p><strong>Abstract</strong></p>
<p>This document examines various ways to compute roots of cubic (3rd order polynomial) and quartic (4th order polynomial) equations in Python. First, two numerical algorithms, available from Numpy package (<code>roots</code> and <code>linalg.eigvals</code>), were analyzed. Then, an optimized closed-form analytical solutions to cubic and quartic equations were implemented and examined. Finally, the analytical solutions were vectorized by using <code>numpy</code> arrays in order to avoid slow python iterations when multiple polynomials are solved. All these functions were evaluated by comparing their computational speeds. Analytical cubic and quartic solvers were one order of magnitude faster than both numerical Numpy functions for a single polynomial. When a large set of polynomials were given as input, the vectorized analytical solver outperformed the numerical Numpy functions by one and two orders of magnitude, respectively.</p>
<p><strong>Keywords:</strong> <em>cubic</em>, <em>quartic</em>, <em>python</em>, <em>numpy</em>, <em>closed-form</em>, <em>polynomial roots</em>, <em>eigenvalues</em>, <em>fqs</em></p>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In scientific computing we are sometimes faced with solving roots of a <a href="https://en.wikipedia.org/wiki/Cubic_function">cubic</a> (3rd order polynomial) or <a href="https://en.wikipedia.org/wiki/Quartic_function">quartic</a> equation (4th order polynomial) to get crucial information about the characteristics of some physical process or to develop an appropriate numerical scheme. These issues are regularly encountered when analyzing coupled dynamic systems described by three or four differential equations. One such example is a two-layer <a href="https://en.wikipedia.org/wiki/Shallow_water_equations">Shallow Water Flow</a> (SWE), which is defined by four <a href="https://en.wikipedia.org/wiki/Partial_differential_equation">Partial Differential Equations</a> (PDE). In two-layer SWE, the <a href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">eigenvalues</a> of the 4x4 flux matrix describe the speed of internal and external wave propagation. And, the eigenvalues correspond to roots of a characteristic 4th order polynomial. Similarly, SWE coupled with sediment transport are defined by three PDEs. In this case, the eigenvalues of a 3x3 matrix correspond to roots of a characteristic 3rd order polynomial. There are many more examples where such computation is required.</p>
<p>Roots of cubic and quartic equations can be computed using <a href="https://en.wikipedia.org/wiki/Numerical_method">numerical methods</a> or analytical expressions (so called <a href="https://en.wikipedia.org/wiki/Closed-form_expression">closed-form solutions</a>). Numerical methods are based on specific algorithms and provide only approximations to roots. <a href="https://en.wikipedia.org/wiki/Root-finding_algorithm">Root-finding algorithms</a> (such as Newton’s, secant, Brent’s method, etc.) are appropriate for any continuous function, they use iterations but do not guarantee that all roots will be found. However, a different class of numerical methods is available (and recommended) for polynomials, based on finding <a href="https://en.wikipedia.org/wiki/Eigenvalue_algorithm">eigenvalues</a> of the companion matrix of a polynomial.</p>
<p>In Python, there are several ways to numerically compute roots of any polynomial; however, only two functions are generally recommended and used. First is a <a href="http://www.numpy.org/">Numpy</a> function called <code>roots</code> which directly computes all roots of a general polynomial, and the second is also a <a href="http://www.numpy.org/">Numpy</a> function from <code>linalg</code> module called <code>eigvals</code>, which computes eigenvalues of a companion matrix constructed from a given (characteristic) polynomial.</p>
<p>On the other hand, analytical <a href="https://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem">closed-form solutions exist for all polynomials of degree lower than five</a>, that is, for quadratic, cubic, and quartic equations. Although, the expressions for cubic and quadratic roots are longer and more complicated than for a quadratic equations, they can still be easily implemented in some computational algorithm. The closed-form solution for roots of cubic equations is based on Cardano’s expressions given <a href="https://en.wikipedia.org/wiki/Cubic_function">here</a> and <a href="http://www.1728.org/cubic2.htm">here</a>. Similarly, solution to the roots for quartic equations is based on Ferrari’s expressions given <a href="https://en.wikipedia.org/wiki/Quartic">here</a> and <a href="http://www.1728.org/quartic2.htm">here.</a> A fast and optimized algorithm - <a href="https://github.com/NKrvavica/fqs">FQS</a> - that uses analytical solutions to cubic and quartic equation was implemented in Python and made publicly available <a href="https://github.com/NKrvavica/fqs">here</a>.</p>
<p>All computational algorithms were implemented in Python 3.7 with Numpy 1.15, and tests were done on Windows 64-bit machine, i5-2500 CPU @ 3.30 GHz.</p>
</section>
<section id="numerical-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="numerical-algorithms">Numerical algorithms</h2>
<section id="function-numpy.roots" class="level3">
<h3 class="anchored" data-anchor-id="function-numpy.roots">Function <code>numpy.roots</code></h3>
<p>Function <code>numpy.roots</code> can compute roots of a general polynomial defined by a list of its coefficients <code>p</code>.</p>
<p>For cubic equations, <code>p</code> is defined as:</p>
<pre><code>p[0]*x**3 + p[1]*x**2 + p[2]*x + p[3],</code></pre>
<p>and for quartic equations, <code>p</code> is defined as:</p>
<pre><code>p[0]*x**4 + p[1]*x**3 + p[2]*x**2 + p[3]*x + p[4].</code></pre>
<p>The function to compute roots of a single polynomial is implemented for cubic roots as follows:</p>
<pre><code>import numpy

p_cubic = numpy.random.rand(4)
cubic_roots = numpy.roots(p_cubic)</code></pre>
<p>and for quartic roots:</p>
<pre><code>p_quartic = numpy.random.rand(5)
quartic_roots = numpy.roots(p_quartic)</code></pre>
<p>The respective results are:</p>
<pre><code>&gt;&gt;&gt; p_cubic
array([0.21129527, 0.23589228, 0.73094489, 0.84747689])
&gt;&gt;&gt; cubic_roots
array([ 0.01557778+1.86945535j,  0.01557778-1.86945535j,
        -1.1475662 +0.j        ]))</code></pre>
<p>and</p>
<pre><code>&gt;&gt;&gt; p_quartic
array([0.30022249, 0.31473263, 0.00791689, 0.06335546, 0.73838408])
&gt;&gt;&gt; quartic_roots
array([-1.19538943+0.7660177j , -1.19538943-0.7660177j ,
        0.67122379+0.87725993j,  0.67122379-0.87725993j])</code></pre>
<p>Let’s look at the computation times using <code>timeit</code> function:</p>
<pre><code>import timeit

%timeit numpy.roots(p_cubic)
76.5 µs ± 148 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

%timeit numpy.roots(p_quartic)
80.1 µs ± 2.98 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</code></pre>
<p>This may seem quite fast; however, what if we need to solve, let’s say, 10 000 polynomials:</p>
<pre><code>p_cubics = numpy.random.rand(10_000, 4)
p_quartics = numpy.random.rand(10_000, 5)</code></pre>
<p>Notice that <code>numpy.roots</code> takes only rank-1 arrays, which means that we have to use <code>for</code> loops or <a href="https://en.wikipedia.org/wiki/List_comprehension">list comprehensions</a>. The latter, are usually faster in python (and more <em>pythonish</em>), therefore we write:</p>
<pre><code>cubic_roots = [numpy.roots(pi) for pi in p_cubics]
quartic_roots = [numpy.roots(pi) for pi in p_quartics]</code></pre>
<p>Their corresponding computation times:</p>
<pre><code>%timeit [numpy.roots(pi) for pi in p_cubics]
786 ms ± 15.6 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit [numpy.roots(pi) for pi in p_quartics]
795 ms ± 2.51 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre>
<p>It seems that it takes 10 000 times longer to compute 10 000 polynomials than 1 polynomial.</p>
<p>Can we speed things up, knowing that loops in Python are slower in comparison to other high level languages, such as C/C++ or FORTRAN?</p>
</section>
<section id="function-numpy.linalg.eigvals" class="level3">
<h3 class="anchored" data-anchor-id="function-numpy.linalg.eigvals">Function <code>numpy.linalg.eigvals</code></h3>
<p>Documentation for <code>numpy.roots</code> states that its algorithms rely on computing the eigenvalues of the <em>companion</em> matrix. It uses the fact that the eigenvalues of a matrix <code>A</code> are the roots of its characteristic polynomial <code>p</code>.</p>
<p>Function <code>numpy.linalg.eigvals</code> computes eigenvalues of a general square matrix <code>A</code> using <em>geev</em> <a href="http://www.netlib.org/lapack/">LAPACK</a> routines. The main advantage of the function <code>linalg.eigvals</code> over <code>roots</code> is that it uses <a href="https://en.wikipedia.org/wiki/Array_programming">vectorization</a>. Meaning, it runs certain operations over entire array, rather than over individual elements. Therefore, it can take as input stacked array of companion matrices, and does not require <code>for</code> loops or list comprehensions.</p>
<p>For cubic equations, first we reduce the polynomial to the form:</p>
<pre><code>x**3 + a*x**2 +b*x + c = 0,</code></pre>
<p>and then construct the companion matrix:</p>
<pre><code>A = [[0, 0, -c],
     [1, 0, -b],
     [0, 1, -a]]</code></pre>
<p>For quartic equations, we reduce the polynomial to the form:</p>
<pre><code>x**4 + a*x**3 + b*x**2 +c*x + d = 0,</code></pre>
<p>and then construct the companion matrix:</p>
<pre><code>A = [[0, 0, 0, -d],
     [1, 0, 0, -c],
     [0, 1, 0, -b],
     [0, 0, 1, -a]]</code></pre>
<p>The function to compute roots from eigenvalues of a single companion matrix is implemented for cubic equation as follows:</p>
<pre><code>def eig_cubic_roots(p):
    
    # Coefficients of quartic equation
    a, b, c = p[:, 1]/p[:, 0], p[:, 2]/p[:, 0], p[:, 3]/p[:, 0]
    
    # Construct the companion matrix
    A = numpy.zeros((len(a), 3, 3))
    A[:, 1:, :2] = numpy.eye(2)
    A[:, :, 2] = -numpy.array([c, b, a]).T
    
    # Compute roots using eigenvalues
    return numpy.linalg.eigvals(A)</code></pre>
<p>Similarly, for quartic equation:</p>
<pre><code>def eig_quartic_roots(p):
    
    # Coefficients of quartic equation
    a, b, c, d = (p[:, 1]/p[:, 0], p[:, 2]/p[:, 0],
                  p[:, 3]/p[:, 0], p[:, 4]/p[:, 0])
    
    # Construct the companion matrix
    A = numpy.zeros((len(a), 4, 4))
    A[:, 1:, :3] = numpy.eye(3)
    A[:, :, 3] = -numpy.array([d, c, b, a]).T
    
    # Compute roots using eigenvalues
    return numpy.linalg.eigvals(A)</code></pre>
<p>To compute roots of a single cubic equation, <code>eigvals</code> is implemented as follows:</p>
<pre><code>cubic_roots = eig_cubic_roots(p_cubic[None, :])</code></pre>
<p>and for quartic roots:</p>
<pre><code>quartic_roots = eig_quartic_roots(p_quartic[None, :])</code></pre>
<p>The results are:</p>
<pre><code>&gt;&gt;&gt; cubic_roots
array([[-1.1475662 +0.j        ,  0.01557778+1.86945535j,
        0.01557778-1.86945535j]])</code></pre>
<p>and <code>&gt;&gt;&gt; quartic_roots &gt;&gt;&gt; quartic_roots array([[ 0.67122379+0.87725993j,  0.67122379-0.87725993j,         -1.19538943+0.7660177j , -1.19538943-0.7660177j ]])</code></p>
<p>Let’s look at the computation times:</p>
<pre><code>%timeit eig_cubic_roots(p_cubic[None, :])
67 µs ± 316 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

%timeit eig_quartic_roots(p_quartic[None, :])
69.3 µs ± 135 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)</code></pre>
<p>The computation times are slightly faster than <code>numpy.roots</code>.</p>
<p>Let see the difference for 10 000 polynomials:</p>
<pre><code>%timeit eig_cubic_roots(p_cubics)
31.2 ms ± 1.05 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

%timeit eig_quartic_roots(p_quartics)
48.3 ms ± 48.6 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</code></pre>
<p>The results indicate that <code>numpy.linalg.eigvals</code> is <strong>one order of magnitude</strong> faster than <code>numpy.roots</code>, and that is a huge gain.</p>
</section>
</section>
<section id="what-about-analytical-solutions-to-cubic-and-quartic-equations" class="level2">
<h2 class="anchored" data-anchor-id="what-about-analytical-solutions-to-cubic-and-quartic-equations">What about analytical solutions to cubic and quartic equations?</h2>
<section id="implementation-for-a-single-polynomial" class="level3">
<h3 class="anchored" data-anchor-id="implementation-for-a-single-polynomial">Implementation for a single polynomial</h3>
<p>Now, let’s look at analytical implementations available by <a href="https://github.com/NKrvavica/fqs">FQS</a> function. First, implementation of analytical solutions for single quadratic, cubic and quartic equation is presented. As stated in the introduction, these algorithms are based on closed-form solutions for cubic (given <a href="https://en.wikipedia.org/wiki/Cubic_function">here</a> and <a href="http://www.1728.org/cubic2.htm">here</a>) and quartic equations (given <a href="https://en.wikipedia.org/wiki/Quartic">here</a> and <a href="http://www.1728.org/quartic2.htm">here</a>). These equations were modified to avoid repeating computations.</p>
<p>Python function for roots of a quadratic equation is implemented as:</p>
<pre><code>import math, cmath

def single_quadratic(a0, b0, c0):
    ''' Reduce the quadratic equation to to form:
        x**2 + a*x + b = 0 '''
    a, b = b0 / a0, c0 / a0

    # Some repeating variables
    a0 = -0.5*a
    delta = a0*a0 - b
    sqrt_delta = cmath.sqrt(delta)

    # Roots
    r1 = a0 - sqrt_delta
    r2 = a0 + sqrt_delta

    return r1, r2</code></pre>
<p>The function for roots of a cubic equation is implemented as:</p>
<pre><code>def single_cubic(a0, b0, c0, d0):
    ''' Reduce the cubic equation to to form:
        x**3 + a*x**2 + b*x + c = 0 '''
    a, b, c = b0 / a0, c0 / a0, d0 / a0

    # Some repeating constants and variables
    third = 1./3.
    a13 = a*third
    a2 = a13*a13
    sqr3 = math.sqrt(3)

    # Additional intermediate variables
    f = third*b - a2
    g = a13 * (2*a2 - b) + c
    h = 0.25*g*g + f*f*f

    def cubic_root(x):
        ''' Compute cubic root of a number while maintaining its sign'''
        if x.real &gt;= 0:
            return x**third
        else:
            return -(-x)**third

    if f == g == h == 0:
        r1 = -cubic_root(c)
        return r1, r1, r1

    elif h &lt;= 0:
        j = math.sqrt(-f)
        k = math.acos(-0.5*g / (j*j*j))
        m = math.cos(third*k)
        n = sqr3 * math.sin(third*k)
        r1 = 2*j*m - a13
        r2 = -j * (m + n) - a13
        r3 = -j * (m - n) - a13
        return r1, r2, r3

    else:
        sqrt_h = cmath.sqrt(h)
        S = cubic_root(-0.5*g + sqrt_h)
        U = cubic_root(-0.5*g - sqrt_h)
        S_plus_U = S + U
        S_minus_U = S - U
        r1 = S_plus_U - a13
        r2 = -0.5*S_plus_U - a13 + S_minus_U*sqr3*0.5j
        r3 = -0.5*S_plus_U - a13 - S_minus_U*sqr3*0.5j
        return r1, r2, r3</code></pre>
<p>And finally, the function for roots of a quartic equation is implemented as:</p>
<pre><code>def single_quartic(a0, b0, c0, d0, e0):
 
    ''' Reduce the quartic equation to to form:
        x**4 + a*x**3 + b*x**2 + c*x + d = 0'''
    a, b, c, d = b0/a0, c0/a0, d0/a0, e0/a0

    # Some repeating variables
    a0 = 0.25*a
    a02 = a0*a0

    # Coefficients of subsidiary cubic equation
    p = 3*a02 - 0.5*b
    q = a*a02 - b*a0 + 0.5*c
    r = 3*a02*a02 - b*a02 + c*a0 - d

    # One root of the cubic equation
    z0, _, _ = single_cubic(1, p, r, p*r - 0.5*q*q)

    # Additional variables
    s = cmath.sqrt(2*p + 2*z0.real + 0j)
    if s == 0:
        t = z0*z0 + r
    else:
        t = -q / s

    # Compute roots by quadratic equations
    r0, r1 = single_quadratic(1, s, z0 + t)
    r2, r3 = single_quadratic(1, -s, z0 - t)

    return r0 - a0, r1 - a0, r2 - a0, r3 - a0</code></pre>
<p>Notice that the quartic solution calls both cubic and quadratic functions.</p>
<p>For a single cubic equation, the results are:</p>
<pre><code>&gt;&gt;&gt; single_cubic(*p_cubic)
((-1.147566194142574+0j),
 (0.01557779507848811+1.8694553386446031j),
 (0.01557779507848811-1.8694553386446031j))</code></pre>
<p>and for a quartic:</p>
<pre><code>&gt;&gt;&gt; single_quartic(*p_quartic)
((-1.195389428644198+0.766017693855147j),
 (-1.195389428644198-0.766017693855147j),
 (0.6712237840251022+0.8772599258280781j),
 (0.6712237840251022-0.8772599258280781j))</code></pre>
<p>Let’s look at the computation times:</p>
<pre><code>%timeit single_cubic(*p_cubic)
28.6 µs ± 604 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)

%timeit single_quartic(*p_quartic)
50.3 µs ± 636 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)</code></pre>
<p>We can notice that <code>single_cubic</code> is <strong>twice as fast</strong> than both numerical solvers implemented in Numpy. Whereas, <code>single_quartic</code> is about 30-40% faster than the numerical solvers.</p>
<p>What about multiple polynomials?</p>
<pre><code>%timeit [single_cubic(*pi) for pi in p_cubics]
236 ms ± 7.89 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit [single_quartic(*pi) for pi in p_quartics]
421 ms ± 1.84 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre>
<p>Analytical closed-form solver is about <strong>twice as fast</strong> than <code>numpy.roots</code>. However, it is much slower (almost one order of magnitude) than the numerical solver from <code>numpy.linalg.eigvals</code>. This difference is mainly the consequence of using list comprehension.</p>
</section>
<section id="just-in-time-compiler-from-numba" class="level3">
<h3 class="anchored" data-anchor-id="just-in-time-compiler-from-numba">Just-in-time compiler from Numba</h3>
<p>Let’s see if we can speed up the computation by using <em>just-in-time</em> compiler from <a href="http://numba.pydata.org/">Numba</a>. We only need to import it and put a decorator before each function:</p>
<pre><code>from numba import jit

@jit(nopython=True)
def single_quadratic(a0, b0, c0):
    ...

@jit(nopython=True)
def single_cubic(a0, b0, c0, d0):
    ...

@jit(nopython=True)
def single_quartic(a0, b0, c0, d0, e0):
    ...
    </code></pre>
<p>These are new computation times after Numba was implemented:</p>
<pre><code>%timeit single_cubic(*p_cubic)
6.34 µs ± 7.75 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)

%timeit single_quartic(*p_quartic)
5.8 µs ± 6.87 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)</code></pre>
<p>We can notice that the algorithms are <strong>several times faster</strong> than both numerical solvers implemented in Numpy.</p>
<p>What about multiple polynomials?</p>
<pre><code>%timeit [single_cubic(*pi) for pi in p_cubics]
27.6 ms ± 80.5 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

%timeit [single_quartic(*pi) for pi in p_quartics]
30.8 ms ± 90.6 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</code></pre>
<p>Analytical closed-form solver (with Numba) is <strong>one order of magnitude faster</strong> than <code>numpy.roots</code> and shows similar performance, but slightly faster, than numerical solver from <code>numpy.linalg.eigvals</code>.</p>
<p>However, notice that list comprehensions were used here for multiple inputs. What if we could vectorize this code using Numpy arrays and speed up computation times even more?</p>
</section>
<section id="vectorized-analytical-closed-form-solvers" class="level3">
<h3 class="anchored" data-anchor-id="vectorized-analytical-closed-form-solvers">Vectorized analytical closed-form solvers</h3>
<p>To vectorize functions <code>single_quadratic</code>, <code>single_cubic</code>, and <code>single_quartic</code> using Numpy arrays we have to get rid of all <code>if</code> clauses and replace them with Numpy masks. Also, we have to replace all mathematical functions from <code>math</code> and <code>cmath</code> with corresponding Numpy functions. This is implemented as follows.</p>
<p>For quadratic equation:</p>
<pre><code>def multi_quadratic(a0, b0, c0):
    # Quadratic coefficient
    a, b = b0 / a0, c0 / a0

    # Some repeating variables
    a0 = -0.5*a
    delta = a0*a0 - b
    sqrt_delta = numpy.sqrt(delta + 0j)

    # Roots
    r1 = a0 - sqrt_delta
    r2 = a0 + sqrt_delta

    return r1, r2</code></pre>
<p>For cubic equation:</p>
<pre><code>def multi_cubic(a0, b0, c0, d0, all_roots=True):
    # Cubic coefficients
    a, b, c = b0 / a0, c0 / a0, d0 / a0

    # Some repeating constants and variables
    third = 1./3.
    a13 = a*third
    a2 = a13*a13
    sqr3 = math.sqrt(3)

    # Additional intermediate variables
    f = third*b - a2
    g = a13 * (2*a2 - b) + c
    h = 0.25*g*g + f*f*f

    # Masks for different combinations of roots
    m1 = (f == 0) &amp; (g == 0) &amp; (h == 0)     # roots are real and equal
    m2 = (~m1) &amp; (h &lt;= 0)                   # roots are real and distinct
    m3 = (~m1) &amp; (~m2)                      # one real root and two complex

    def cubic_root(x):
        ''' Compute cubic root of a number while maintaining its sign
        '''
        root = numpy.zeros_like(x)
        positive = (x &gt;= 0)
        negative = ~positive
        root[positive] = x[positive]**third
        root[negative] = -(-x[negative])**third
        return root

    def roots_all_real_equal(c):
        ''' Compute cubic roots if all roots are real and equal
        '''
        r1 = -cubic_root(c)
        if all_roots:
            return r1, r1, r1
        else:
            return r1

    def roots_all_real_distinct(a13, f, g, h):
        ''' Compute cubic roots if all roots are real and distinct
        '''
        j = numpy.sqrt(-f)
        k = numpy.arccos(-0.5*g / (j*j*j))
        m = numpy.cos(third*k)
        r1 = 2*j*m - a13
        if all_roots:
            n = sqr3 * numpy.sin(third*k)
            r2 = -j * (m + n) - a13
            r3 = -j * (m - n) - a13
            return r1, r2, r3
        else:
            return r1

    def roots_one_real(a13, g, h):
        ''' Compute cubic roots if one root is real and other two are complex
        '''
        sqrt_h = numpy.sqrt(h)
        S = cubic_root(-0.5*g + sqrt_h)
        U = cubic_root(-0.5*g - sqrt_h)
        S_plus_U = S + U
        r1 = S_plus_U - a13
        if all_roots:
            S_minus_U = S - U
            r2 = -0.5*S_plus_U - a13 + S_minus_U*sqr3*0.5j
            r3 = -0.5*S_plus_U - a13 - S_minus_U*sqr3*0.5j
            return r1, r2, r3
        else:
            return r1

    # Compute roots
    if all_roots:
        roots = numpy.zeros((3, len(a))).astype(complex)
        roots[:, m1] = roots_all_real_equal(c[m1])
        roots[:, m2] = roots_all_real_distinct(a13[m2], f[m2], g[m2], h[m2])
        roots[:, m3] = roots_one_real(a13[m3], g[m3], h[m3])
    else:
        roots = numpy.zeros(len(a))
        roots[m1] = roots_all_real_equal(c[m1])
        roots[m2] = roots_all_real_distinct(a13[m2], f[m2], g[m2], h[m2])
        roots[m3] = roots_one_real(a13[m3], g[m3], h[m3])

    return roots</code></pre>
<p>And for quadratic equation:</p>
<pre><code>def multi_quartic(a0, b0, c0, d0, e0):
    # Quartic coefficients
    a, b, c, d = b0/a0, c0/a0, d0/a0, e0/a0

    # Some repeating variables
    a0 = 0.25*a
    a02 = a0*a0

    # Coefficients of subsidiary cubic equation
    p = 3*a02 - 0.5*b
    q = a*a02 - b*a0 + 0.5*c
    r = 3*a02*a02 - b*a02 + c*a0 - d

    # One root of the cubic equation
    z0 = multi_cubic(1, p, r, p*r - 0.5*q*q, all_roots=False)

    # Additional variables
    s = numpy.sqrt(2*p + 2*z0.real + 0j)
    t = numpy.zeros_like(s)
    mask = (s == 0)
    t[mask] = z0[mask]*z0[mask] + r[mask]
    t[~mask] = -q[~mask] / s[~mask]

    # Compute roots by quadratic equations
    r0, r1 = solve_multi_quadratic(1, s, z0 + t) - a0
    r2, r3 = solve_multi_quadratic(1, -s, z0 - t) - a0

    return r0, r1, r2, r3</code></pre>
<p>Let’s examine the computation time of vectorized analytical closed-form solvers for a single polynomial:</p>
<pre><code>%timeit multi_cubic(*p_cubic.T)
174 µs ± 2.02 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)

%timeit multi_quartic(*p_quartic.T)
233 µs ± 4.91 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</code></pre>
<p>Clearly, vectorized version for a single polynomial is overkill, and results in slowest computation times.</p>
<p>But what about multiple polynomials:</p>
<pre><code>%timeit multi_cubic(*p_cubics.T)
3.14 ms ± 13.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

%timeit multi_quartic(*p_quartics.T)
5.46 ms ± 38.5 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></pre>
<p>The vectorized implementation of analytical solvers is an order of magnitude faster than original analytical implementation, even with <em>just-in-time</em> compiler from Numba. Furthermore, the vectorized implementation is two order of magnitudes faster than the numerical solver <code>roots</code> and also one-order of magnitude faster than <code>linalg.eigvals</code>.</p>
</section>
</section>
<section id="summary-tldr" class="level2">
<h2 class="anchored" data-anchor-id="summary-tldr">Summary (TL;DR)</h2>
<p>Findings on computation speed of different ways to solve cubic and quartic equations in Python can be summarized as follows:</p>
<ul>
<li>Two numerical algorithms for finding polynomial roots are available out-of-box from Numpy package (<code>numpy.roots</code> and <code>numpy.linalg.eigvals</code>)</li>
<li>Analytical algorithms (closed-form solutions) for solving polynomial roots were implemented in Python (<code>single_cubic/single_quartic</code> for a single polynomial, and vectorized <code>multi_cubic/multi_quartic</code> for multiple polynomials). These functions are available through <a href="https://github.com/NKrvavica/fqs">FQS</a></li>
<li>Both numerical algorithms have similar CPU times for a single polynomial, but for multiple polynomials <code>linalg.eigvals</code> becomes much faster (up to one order of magnitude)</li>
<li>Analytical algorithm <code>single_cubic/single_quartic</code> is the fastest when a single polynomial, or a set smaller then 100 polynomials should be solved</li>
<li>For <code>single_cubic/single_quartic</code> <em>just-in-time</em> compiler from Numba gives a significant increase in the computational speed</li>
<li>Analytical algorithm <code>multi_cubic/multi_quartic</code> is the fastest when a set larger than 100 polynomials is given as input</li>
<li>A Python function containing <code>single_cubic</code> , <code>single_quartic</code>, <code>multi_cubic</code>, and <code>multi_quartic</code>, as well as a function than determines what solver should be used in a specific case, is available through <a href="https://github.com/NKrvavica/fqs">FQS</a>.</li>
</ul>
<p>The CPU times are summarized in the following two tables for different number of polynomials (Nr.) and separately for cubic and quartic equations:</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 9%">
<col style="width: 21%">
<col style="width: 18%">
<col style="width: 26%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Nr.</th>
<th><code>roots</code></th>
<th><code>linalg.eigvals</code></th>
<th><code>single_cubic</code></th>
<th><code>single_cubic(@jit)</code></th>
<th><code>multi_cubic</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td>76.5 µs</td>
<td>67 µs</td>
<td>28.6 µs</td>
<td><strong>6.34 µs</strong></td>
<td>174 µs</td>
</tr>
<tr class="even">
<td style="text-align: right;">100</td>
<td>8.19 ms</td>
<td>0.54 ms</td>
<td>2.11 ms</td>
<td><strong>0.27 ms</strong></td>
<td><strong>0.24 ms</strong></td>
</tr>
<tr class="odd">
<td style="text-align: right;">10000</td>
<td>786 ms</td>
<td>31.2 ms</td>
<td>236 ms</td>
<td>27.6 ms</td>
<td><strong>3.14 ms</strong></td>
</tr>
</tbody>
</table>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 8%">
<col style="width: 19%">
<col style="width: 19%">
<col style="width: 28%">
<col style="width: 18%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: right;">Nr.</th>
<th><code>roots</code></th>
<th><code>linalg.eigvals</code></th>
<th><code>single_quartic</code></th>
<th><code>single_quartic (@jit)</code></th>
<th><code>multi_quartic</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td>80.1 µs</td>
<td>69.3 µs</td>
<td>50.3 µs</td>
<td><strong>5.8 µs</strong></td>
<td>233 µs</td>
</tr>
<tr class="even">
<td style="text-align: right;">100</td>
<td>8.22 ms</td>
<td>0.59 ms</td>
<td>3.94 ms</td>
<td><strong>0.33 ms</strong></td>
<td><strong>0.34 ms</strong></td>
</tr>
<tr class="odd">
<td style="text-align: right;">10000</td>
<td>795 ms</td>
<td>48.3 ms</td>
<td>421 ms</td>
<td>30.8 ms</td>
<td><strong>5.46 ms</strong></td>
</tr>
</tbody>
</table>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>